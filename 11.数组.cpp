#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
//数组的创建

//数组:相同类型元素的集合
//数组的元素类型 数组名字 [常量表达式]
//type_t arr_name[const_t]

//int main()
//{
//	int arr[10];
//	double datal[20];
//	double data2[15 + 5];
//	char ch[5];
//	//[括号里面]
//	//C99标准之前,数组的大小必须是常量或者常量表达式
//	//c99之后,数组的大小可以是变量,为了支持变长(元素大小决定变量长度)数组
//	int n = 10;
//	scanf("%d", &n);
//	int arr2[n];//这种数组不能初始化--在创建数组是给一些合理的值
//
//
//	return 0;
//
//}


//int main()
//{
//	int arr[10] = { 1, 2, 3 };//不完全初始化,其它的值默认为0,可通过调试查看
//	char ch1[10] = { 'a', 'b', 'c' };//同上	这个实质是		abc
//	char ch2[10] = "abc";//也默认是0		字符串的实质	"abc\0"
//	
//	int arr3[] = { 1, 2, 3 }; //这个是不给定数字,根据元素个数给定长度
//	char ch3[] = { 'a', 'b', 'c' }; //三个元素
//	char ch4[] = "abc";  //四个元素
//	return 0;
//}


//一维数组 
//[]: 下标引用操作符

//int main()
//{
//	int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
//	//在栈区里面找到了'一个连续空间'存了10个元素
//	//这是元素有个名字叫:数组名
//	//
//	//printf("%d\n", arr[4]);
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//for (i = 0; i < sz; i++)
//	//{
//	//	printf("%d\n", arr[i]);
//	//}
//	for (i = sz - 1; i >= 0; i--)
//	{
//		printf("%d\n", arr[i]);
//	}
//	return 0;
//
//}

//一维数组在内存中的储存

//int main()
//{
//	int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
//	//在栈区里面找到了'一个连续空间'存了10个元素
//	//这是元素有个名字叫:数组名
//	//
//	//printf("%d\n", arr[4]);
//	int i = 0;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	//for (i = 0; i < sz; i++)
//	//{
//	//	printf("%d\n", arr[i]);
//	//}
//
//	for (i = sz - 1; i >= 0; i--)
//	{
//		int* p = &arr[i];// 实际上不用每个都占用内存,直接调用
//		//打印数组的每个元素
//		printf("取元素arr[%d] = %p\n", i,p);//读作:取这个地址上的值
//											//如果是p读作:取地址
//
//		//printf("取元素arr[%d] = %p\n", i, &arr[i]);//读作&取地址
//		//得到结果每个地址相差4个字节  ->一维数组是连续存放的
//		//随着数组下标的增长,元素的地址也是有规律的增长.
//	}
//	return 0;
//
//}


//int main() {
//    int arr[] = { 1, 2, 3, 4, 5 };
//    int* ptr;
//
//    ptr = &arr[1];
//
//    printf("ptr 指向的地址：%p\n", ptr);
//    printf("ptr 指向的值：%d\n", *ptr);
//
//    return 0;
//}



//二维数组

//二维数组的创建

//基础语法:	数组类型 数组名[行数][列数]

//存储
//1 2 3 4 
//2 3 4 5 
//3 4 5 6

//int main()
//{
//
//	//基础的创建
//	int arr1[3][4] =
//	{	1, 2, 3, 4,
//		2, 3, 4, 5,
//		3, 4, 5, 6 };//如果每填满,就一次补满
//	//行可以省略,列不可以省略 
//	int arr4[][4] = { { 1, 2, 3, 4 }, {5, 6} };
//	//自动推断有多少行,一行慢了就放到下一行,因为列确定了,一行就四列(四个元素)
//	// 从0开始;arr[行][列] 可以取到这个元素,进行操作
//	int arr3[3][4] = { {1, 2}, {2, 3}, {3, 4} };
//	//监视一下看到内容的组成
//	char arr2[5][10];
//
//	return 0;
//}

//二维数组可视为一维数组的 数组


//二维数组的存储
//实际二维数组也是连续的,每一行都是一个数组,数组和数组是连续存放的(差4个字节)
//int main()
//{
//	int arr1[3][4] = { {1, 2, 3, 4}, {2, 3, 4, 5}, {3, 4, 5, 6} };
//	int i = 0;
//	int j = 0;
//	// i 是行 j 是列
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j < 4; j++)
//		{
//			printf("arr1[%d][%d] = %p\n", i, j, &arr1[i][j]);
//		}
//	}
//
//	return 0;
//}


//数组越界,编译器可能不报错

//int main()
//{
//	int arr1[] = { 1, 2, 3, 4, 5, 6 };
//	int i = 0;
//	int sz = sizeof(arr1) / sizeof(arr1[0]);
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d ", arr1[i]);
//	}
//	return 0;
//}
//越界后面的数字是错误的


//int main()
//{
//	int arr[3][4] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12 };
//	int i = 0;
//		int j = 0;
//	for (i = 0; i < 3; i++)
//	{
//		for (j = 0; j <= 4; j++)
//		{
//			printf("%d ", arr[i][j]);
//		}
//	}
//}

//在同前几行里越界，还能打印到后面的元素, 最后一行越界,就错误了



//数组传参有两种写法
//1.数组: void bubble_sort(int arr1[])
//2.指针
//void bubble_sort(int* tuple_path, int sz)
//{
//	//趟数
//	//函数内部计算得不到, 需要在函数外部计算, 再穿进去
//	int i = 0;
//	//比较 交换
//	for (i = 0; i < sz; i++)
//	{
//		//比较的次数,第一次是0-9第二次是0-8
//		int j = 0;
//		for (j = 0; j < sz - i - 1; j ++)//终止条件 sz = 10 最后时 i = 9
//		{
//			//比较
//			if (tuple_path[j] > tuple_path[j + 1])
//			{
//				int tmp = tuple_path[j];
//				tuple_path[j] = tuple_path[j +1];
//				tuple_path[j + 1] = tmp;
//			}
//		}
//	}
//}
//
//int main()
//{
//	int arr[] = { 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };
//	//把数组的顺序变成升序0->9
//	//冒泡排序的算法
//	//{两个相邻的元素进行比较, 不满足就交换}
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	bubble_sort(arr, sz);
//	int i = 0;
//	for (i = 0; i < sz; i++)
//	{
//		printf("%d, ", arr[i]);
//	}
//	return 0;
//}


//数组名是什么

//但有连个意外
//1. sizeof (数组名), 这里的数组名表示整个数组,计算的是整个数组的大小,单位是字节
//2. &数组名,这里的数组名,表示整个数组, 取出的事整个数组的地址
//3. 
//int main()
//{
//	int arr[10];
//	printf("%p\n", arr);//arr就是首元素的地址
//	printf("%p\n", arr+1);
//	printf("---------------");
//	printf("%p\n", &arr[0]);//首元素的地址
//	printf("%p\n", &arr[0]+1);
//
//	printf("---------------");
//	printf("%p\n", &arr);//整个数组的地址, 结果这两个地址差了0x28个字节 = 40个字节
//	printf("%p\n", &arr+1);//跳过了整个地址
//
//	printf("---------------");
//	int n = sizeof(arr);
//	printf("%d\n", n);
//
//	return 0;
//}

//二维数组
//int main()
//{
//	int arr[3][4];
//	printf("%d\n", sizeof(arr) / sizeof(arr[0])); // 算的结果是行
//	printf("%d\n", sizeof(arr[0]) / sizeof(arr[0][0])); 
//	// 用第一个整个数组除以一个元素的尺寸,得到的就是列,而每个数组的列都是一样的,所以所有的都算出来了
//	
//	
//	
//	//int sz = sizeof(arr);
//	//printf("%d\n", sz);3*4*4=48字节
//	arr;//二维数组的数组名也表示数组首元素的地址; 
//	//首元素实际上就是一个数组,他的地址就是第一个数组的首元素的地址
//	
//	//这不就是数组的嵌套吗,但是每个数组的尺寸需要一样!!!【愤怒】
//	
//	return 0;
//}
