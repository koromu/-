#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
int main()
{
	//一.算数操作符
	//1.整型的除法		1 / 2 = 0,

	//2.浮点型的除法	1.0 / 2 = 0.5
	//					1 / 2.0 = 0.5两边至少有个浮点数

	//3.取模操作符		% 取模操作符的两段必须是整数


	//二.移位操作符
	//1.<<	左移操作符
	
	//int a = -7;		//a的值不变
	//int b = a << 1;//按照下面的推断b是向左移动移位, 结果是7->14 -7->-14
	//printf("a=%d\n", a);
	//printf("b=%d\n", b);
	//整数的二进制表示有3种: 原码 反码 补码


	//正的整数的原码,反码,补码是要计算的
	//eg:7
	//0(符号位0是正数)00000000000000000000000000000111(原码)
	//0(符号位0是正数)00000000000000000000000000000111(反码)
	//0(符号位0是正数)00000000000000000000000000000111(补码)
	//eg:-7
	//1(符号位1是负数)00000000000000000000000000000111(原码)
	//1(符号位1是负数)11111111111111111111111111111000(反码)(原码的符号位不变,其它的位按位取反)
	//1(符号位1是负数)11111111111111111111111111111001(补码)(反码+1就是补码,满2进位)
	
	//整数在内存中的存储是补码
	//移位就是移动补码
	//左移操作符:
	//左边丢失,右边补0

	//打印室打印原码
	//左移右移只针对整数

	//2.>>	:右移操作符(vs2022, 编译器采用的算数位移)
	//2.1 : 算数移位 :右边丢失, 左边补原符号位(保留原来符号)
	//2.2 : 逻辑移位 :右边丢失, 左边补0(符号丢了呀)
	//int a = -7;		//a的值不变
	//int b = a >> 1;//按照下面的推断b是向右移动移位, 结果是7->3 -7->-4
	//printf("a=%d\n", a);
	//printf("b=%d\n", b);
	//移的位需要时正数,负数未定义,可能得不到目标数字


	//三.位操作符
	//1.& - 按(2进制)位 与 (使用补码)(与的结果: 只有两个都是1,才的=得1)
	//		1.1	同真1	异假0
	//2.| - 按(2进制)位或
	//		2.1一个为真就是真
	//3.^ - 按(2进制)位异或
	//		3.1 同假0	异真1
	//整数4字节一个字节8个比特位
	//10000000000000000000000000000101 - -5的原码
	//11111111111111111111111111111010 - -5的反码

	//00000000000000000000000000000011 - 3的补码
	//11111111111111111111111111111011 - -5的补码

	//00000000000000000000000000000011 = a&b 的补码 = 

	//11111111111111111111111111111011 = a|b 的补码
	//11111111111111111111111111111010	符号位不变哦!!!
	//10000000000000000000000000000101 = a|b 的原码 = -5

	//11111111111111111111111111111000
	//11111111111111111111111111110111
	//10000000000000000000000000001000 = a^b 的原码 = 8

	//%d 以为着打印一个有符号的整数(原码)
	//补码储存在内存

	//int a = 3;
	//int b = -5;
	//int c = a & b;
	//printf("c = %d\n", c);
	//int a = 3;
	//int b = -5;
	//int c = a | b;
	//printf("c = %d\n", c);
	//int a = 3;
	//int b = -5;
	//int c = a ^ b;
	//printf("c = %d\n", c);
	//3 ^ 3 = 0; -> a ^ a = 0;
	//0 ^ 5 = 5; -> 0 ^ a = a;

	//3 ^ 5 ^ 3 = 5;
	//3 ^ 3 ^ 5 = 5; -> 异或支持交换律


	//练习:不创造临时变量(第三个变量), 实现两个变量的交换
	//int a = 99;
	//int b = 66;
	////a = a + b;
	////b = a - b;
	////a = a - b; // 方法一:会有溢出的问题
	//a = a ^ b;
	//b = b ^ a;
	//a = a ^ b;//异或的交换律
	//printf("交换前a = %d, b =%d\n", a, b);

	//printf("交换后a = %d, b =%d\n", a, b);





//复制操作符
//单目操作符










	return 0;
}