#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <assert.h>

//补充:release版本会优化

//int main()
//{
//	int i = 0;
//	int arr[10] = { 1, 2, 3, 4, 5, 6, 7 ,8 ,9 ,10 };
//	for (i = 0; i <= 12; i++)
//	{
//		arr[i] = 0;
//		printf("hehe\n");
//	}
//	return 0;
//}
//陷阱案例.x86的debug内存空间中是死循环
//release中打印了13次
//通过查看地址发现release中i在低地址 ,所以被优化了呢.
//按道理在栈区中从'高地址'到'低地址'占用内存,所以'i在高地址' 'arr在低地址',arr访问'从低地址'向'高地址'越界后会访问到'高地址的i'
//



//进阶
//数据类型介绍			   大小(字节)
//char		字符类型		1
//short		短整型			2
//int		整型			4
//long		长整型			4/8
//long long 更长的整型		8
//float		单精度浮点型	4
//double	双精度浮点型	8


//整型家族
//char (字符的本质是ASCII码值, 是整型)
//	unsigned char(不默认, 取决于编译器)
//	signed char(不默认,取决于编译器)
//
//short
//	unsigned short[int]
//	signed short[int](默认)
//
//int
//	unsigned int
//	signed int(默认)
//
//long
//	unsigned long[int]
//	signed long[int](默认)

//unsigned 有些数据是没有负数的 
//int a = 0
//00000000000000000000000000000000
//符号位1是负数, 0是负数 -> 有符号signed的数
//unsigned int high; -> 无符号
//每一个位都是有意义的数, 第32位也是有效



//浮点型家族
//float 的精度低, 存储的数值范围小,
//double


//构造类型::自定义类型 - 可以自己创造出新的类型
//1.数组类型 int arr[]; char arr[]
//2.结构体类型struct
//3.枚举类型enum
//4.联合类型union

//指针类型:
//char* pc
//int* pi
//void* pv

//空类型:void
//void test(void)
//{
//	printf("hehe\n");
//}
//第一个void表示不会返回值, 第二个void表示函数不需要传任何参数(传进去也会运行,但是会警报)


//整型在内存中的存储

//数值有不同的表示形式 -> 2进制, 8进制, 16进制, 10进制
//21(十进制) -> 0b10101(二进制) -> 025(八进制) -> 0x15(十六进制).每个位都有自己的权重

//2进制也有三种表示形式:原码, 反码, 补码
//1.正整数原反补相同
//2.负的整数需要计算

//int main()
//{
//	int a = 20;
//	int b = -10;
//	//10000000000000000000000000001010--原码
//	//0x80 00 00 0a
//	//11111111111111111111111111110101--反码
//	//0xff ff ff f5
//	//11111111111111111111111111110110--补码
//	//0xff ff ff f6
//	//没4个二进制位写成一个2进制位得到的就是16进制,(符号位也算进去)
//
//
//	//从内存窗口观察,发现b的值是补码的二进制.整数在内存中存放的是补码的二进制序列
//	//原因在于: 可以将符号位和数值域统一处理;
//	
//	//特点:cpu只有加法器
//	
//	//00000000000000000000000000000001
//	//10000000000000000000000000000001 原码相加得 -2 错误
//	//11111111111111111111111111111111 补码相加得如下
//	//100000000000000000000000000000000 33位丢失所以变成
//	//00000000000000000000000000000000 得到 0 正确
//
//
//	//特点:原码:取反, 加一得到补码
//	//    :补码:取反, 加一得到原码		.所以运算过程不需要额外的电路
//	return 0;
//}

//大小端
//0x 11 22 33 44 2个16进制是一个字节(以字节为单位, 讨论存入的方式)
// -> 把一个数据的高位字节序的内容存放在低地址处,把低位字节序的内容放在高地址处:读作:大端[字节序]存储
// -> 把一个数据的高位字节序的内容存放在高地址处,把低位字节序的内容放在低地址处:读作:小端[字节序]存储
// 个位低, 十位高

//内存:低地址 -> 高地址(需要按存入内存的方式, 反过来取出来)


//机器自主判断是大段还是小端
//int main()
//{
//	int a = 1;
//	if (*(char*)&a == 1) //目的:一次性读取一个字节.本来是int, 取地址后是*int一次读四个字节. 所以使用只读一个的指针类型:字符指针,所以强制转化成(*char)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大段\n");
//	}
//	return 0;
//}



//一个有符号的char的取值范围: -128~127
//一个无符号的char的取值范围: 0~255
//一个字节
//int main()
//{
//	unsigned char a = -1;//只能存8个比特位, 一个字节 原本32个比特位的整型需要被［截断］
//	signed char b = -1;
//	char c = -1;//这里默认有符号
//	printf("a=%d b=%d c=%d ", (int)a, b, c);//%d意味着有符号位整型, char需要提升补码 -> 按符号位从高位补齐32个比特位(无符号位直接高位补0) 
//
//	return 0;
//}

//int main()
//{
//	//char a = -128;
//	////10000000000000000000000010000000
//	////11111111111111111111111101111111
//	////11111111111111111111111110000000
//	////截断
//	////10000000 - a
//	////提升
//	////11111111111111111111111110000000
//	////无符号整数打印,无符号数相当于整数, 没有原反补的概念, 直接打印这个提升的补码
//	////10000000000000000000000001111111
//	////10000000000000000000000010000000 = -128 %d的结果需要先变成原码
//	//
//	//printf("%u\n", a);
//
//	char a = 128;
//	//00000000000000000000000010000000 正数原反补相同
//	//截断
//	//10000000
//	//提升
//	//11111111111111111111111110000000 char是有符号的
//	//打印无符号整型
//	printf("%u\n",a);
//	printf("%d\n",a);//有符号数, 认为存的是补码, 需要读原码
//	//10000000000000000000000001111111
//	//10000000000000000000000010000000 -128
//
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100
//	//11111111111111111111111111101011
//	//11111111111111111111111111101100补码
//
//	unsigned int j = 10;
//	//00000000000000000000000000001010
//	printf("%d\n", i + j);
//	//
//	//00000000000000000000000000001010 10
//	//11111111111111111111111111101100 -20补码
//	//11111111111111111111111111110110 结果的补码
//	//10000000000000000000000000001001
//	//10000000000000000000000000001010 -10
//	//
//	return 0;
//}

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%ud\n", i);
//		//Sleep(1000);
//	}
//	//00000000000000000000000000000000 0
//	//10000000000000000000000000000001 -1的原码
//	//11111111111111111111111111111110 
//	//11111111111111111111111111111111 -1的补码
//	//11111111111111111111111111111111 i是无符号数 与-1相加得到的是超大的这个数,无符号就是正数
//
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//
//	printf("%d", strlen(a));
//	//strlen 是求字符串的长度,关注的是'\0'(和数字0的ASCII值相同)之前出现多少个字符
//	//a的元素 -1 -2 -3 -4 ... -128 127 126 ... 3 2 1 0 -1//所以0前面有127+128 
//	return 0;
//}


//int main()
//{
//	unsigned char i;//范围是0~255
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hehe\n");
//	}
//
//	return 0;
//}

//strlen(size_t) 参数是 unsigned int 因为长度不会是负数所以无符号数的四则运算也是无符号数,也是无符号数 也是正数

//算术转换
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//上面的强于下面的(四则运算是下面的会转化成下面的)

//int my_strlen(const char* temp)
//{
//	assert(temp);
//	int len = 0;
//
//	while (*temp++)
//	{
//		len++;
//	}
//	return len;
//}
//int main()
//{
//	if (my_strlen("abc") - my_strlen("abcdef") >= 0)
//	{
//		printf(">\n");
//	}
//	else
//	{
//		printf("<\n");
//	}
//
//	return 0;
//}

//浮点型在内存中的储存 (1E10 = 1.0*10^10)
//浮点数的类型(取值范围float.h可以查看定义),

//int main()
//{
//	int n = 9;
//	//00000000000000000000000000001001
//	float* pFloat = (float*)&n;
//
//	printf("n的值为: %d\n", n);//9
//
//	//00000000000000000000000000001001
//	// 
////整型的补码传给浮点数, 浮点数按照浮点数的读取方法
//	//0 00000000 00000000000000000001001
//	//E = -127
//	//M = 0.0000000000000000001001
//	//+0.0000000000000000001001 * 2^(-127)
//	printf("&pFloat的值为: %f\n", *pFloat);
//	*pFloat = 9.0; // 改变n的值
//	//按浮点的存储方法
//	//1001.0
//	//s=0, m=1.0010, e = 3
//	//s =0 , E = 130 M = 10010
//	//0 10000010 10010000000000000000000
//	//0100 0001 0100 1000 0000 0000 0000 0000
//	//直接当成整型的补码,整数那就相当于原码1091567616
//	printf("n的值为: %d\n", n);
//
//	//以浮点数看
//	//0100 0001 0100 1000 0000 0000 0000 0000
//	//得到浮点数9.0
//	printf("*pFloat的值为: %f\n", *pFloat);//
//
//	return 0;
//}

//浮点数的存数规则
// 
//任何一个二进制浮点数V:V = (-1)^S * M * 2^E

//S表示正负数
//M表示有效数字
//E表示位数
//V = 5.0f -> 101.0(二进制) -> 1.01 * 2^2 -> (-1)^0 * 1.01 * 2^2
											   //S    M       E
//V = 9.5f -> 1001.1 -> 1.0011 * 2^3 ->     (-1)^0 * 1.0011 * 2^3

//V = 9.6f -> 1001.1001...00010110110(可能表示不出来)
//float四个字节 
//double八个字节,都有可能无法精确保存

//规定:float S(符号位, 1个比特位), E(有效数字, 11个比特位), M(52个比特位) --- 64位
//规定:float S(符号位, 1个比特位), E(有效数字, 8个比特位), M(23个比特位) --- 32位



//1<M<2, 也就是可以表达成1._____.所以储存时第一位省略
//1.E为一个无符号整数,为了防止负数, 所以规定
//float中,E有8个比特位, E的真实值要加127(中间值)
//double中,E有11个比特位, E的真实值要加1023(中间值)


//int main()
//{
//	float f = 5.5f;
//	//5.5
//	//101.1
//	//1.011
//	//(-1)*2^(0) * 1.011*  2^2
//	//		s=0, m=1.011 e=2
//	//所以E = 2 + 127 =129 =128 +1
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//0x40 b0 00 00
//	printf("%p\n", (void*) & f);
//	return 0;
//}

//E从内存中取出还可以分三种情况
//不全为0, 不全为1
//存储的值-127/1023,得到正式值

//特殊:E为全0
//此时说明E的正式值是-127 表示正负无穷接近于0的数字

//特俗:E为全1
//此时说明E的正式值为128 表示正负无穷大的数字(正负取决于s位)

//不管整型还是浮点型都有大小端的区别