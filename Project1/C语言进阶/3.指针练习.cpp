#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <assert.h>
#include <stdlib.h>

//
//数组名的意义
//指针运算和指针类型的意义
//

//int main()
//{
//	int a[] = { 1,2,3,4 };
//	printf("%d\n", sizeof(a));//16
//	//16字节, 整个数组
//
//	printf("%d\n", sizeof(a + 0));//4/8
//	//a不是单独放在sizeof内部, 也没有取地址, 所以a就是首元素的地址, a+0还是首元素地址
//	//是地址, 大小是4/8个字节
//	//a == &a[0]
//	//a+0 == &a[0]+0
//
//	printf("%d\n", sizeof(*a));//4
//	//a是首元素地址, *a解引用得到首元素
//	//首元素的大小就是4个字节
//
//	printf("%d\n", sizeof(a + 1));//4/8
//	//同上上+1得到第二个元素的地址, 4或者8
//
//	printf("%d\n", sizeof(a[1]));//4
//	//第二个元素的大小
//
//	printf("%d\n", sizeof(&a));//4/8
//	//数组的地址, 也是地址, 计算地址的大小
//
//	printf("%d\n", sizeof(*&a));//16
//	//取地址解引用抵消, 还是a所以是单独的一个a, 计算数组的大小16
//	//&a  ->  int(*)[4]数组指针  ->  对数组指针解引用找到数组
//
//
//	printf("%d\n", sizeof(&a + 1));//4/8
//	//数组地址 +1 跳过整个(有四个整型元素)数组,
//	//计算的是某个地址的大小 
//	printf("%d\n", sizeof(&a[0]));//4/8
//	//第一个元素地址的大小
//	printf("%d\n", sizeof(&a[0] + 1));//4/8
//	//第二个元素地址的大小 -> &a[1]
//	return 0;
//}

//int main()
//{
//	//char arr[] = { 'a','b','c','d','e','f' };//这个数组后面没有'\0'
//	//printf("%d\n", sizeof(arr));//6
//	////sizeof()关注所占内存空间的大小, 例外: sizeof内部单独放个数组名, 表示整个数组
//	//printf("%d\n", sizeof(arr + 0));//4/8
//	////不是单独, 表示数组首元素地址, +0 还是数组首元素地址, 4/8
//	//printf("%d\n", sizeof(*arr));//1
//	////解引用表示首元素, 是个字符 
//	//printf("%d\n", sizeof(arr[1]));//1
//	////第二个元素
//	//printf("%d\n", sizeof(&arr));//4/8
//	////是数组的地址, 
//	//printf("%d\n", sizeof(&arr + 1));
//	////+1跳过整个数组,但是还是地址
//	//printf("%d\n", sizeof(&arr[0] + 1));//4/8
//	////第二个元素地址
//	//printf("%d\n", sizeof(arr[0]) + 1);//4
//	////第一个元素加一, 字符床和整型在一起, 整形提升, 所以计算的是一个整型的大小, 既4个字节
//
//
//	//printf("%zu\n", strlen(arr));//随机值
//	//printf("%zu\n", strlen(arr + 0));//随机数,数组没有以 null 字符结尾，无法使用 strlen(), 会在后面随机找一个\0才停止, 所以是随机值
//
//	////printf("%zu\n", strlen(*arr)); //strlen(const char* a) 传入的是个地址, 所以传入的是arr首元素的地址, 计算的是ASCII码值的地址, a -> 97的地址, 非法闯入//97是个野指针(地址)
//	////printf("%zu\n", strlen(arr[1])); //传入看个b -> 98 , 所以计算的是98的地址, 是个野指针(地址)(报错:读取访问冲突)
//
//	//printf("%zu\n", strlen(&arr));    //取出数组的地址, 和数组首元素地址是一样的,所以对于strlen还是往后面找得到的随机值是一样的
//	//printf("%zu\n", strlen(&arr + 1));//是随机值-6, 因为跳过了这个数组
//	//printf("%zu\n", strlen(&arr[0] + 1));//随机值-1.
//
//	char arr[] = "abcdef";
//	//sizeof只关注占用内存空间大小, 不在乎内存中放的是什么
//	//sizeof是个操作符
//	//printf("%d\n", sizeof(arr));//7, 字符串后面有'\0'
//	////[a b c d e f \0]
//	//printf("%d\n", sizeof(arr + 0));//4/8
//	////首元素地址+0还是首元素地址, 还是指针
//	//printf("%d\n", sizeof(*arr));//1
//	////数组名是首元素地址, 解引用得到首元素, 是一个字节
//	//printf("%d\n", sizeof(arr[1]));//1
//	//printf("%d\n", sizeof(&arr));//4/8
//	////取地址,不过取的是整个数组地址, 是个指针4/8
//	//printf("%d\n", sizeof(&arr + 1));//4/8
//	////跳过整个数组, 还是个地址
//	//printf("%d\n", sizeof(&arr[0] + 1));//4/8
//	////首元素地址加1,还是地址 
//
//	printf("%d\n", strlen(arr));//6
//	//strlen 是求求字符串长度的, 关注的是'\0'之前出现的字符个数
//	//strlen是个库函数
//	printf("%d\n", strlen(arr + 0));//6
//	//给了个首元素地址, 然后从首元素开始找\0
//	
//	//printf("%d\n", strlen(*arr));//首元素, 传错东西了
//	//printf("%d\n", strlen(arr[1]));//第二个元素, 也传错东西了
//	printf("%d\n", strlen((char * ) & arr));//6
//	//整个元素地址(数组指针), 但还是从首元素地址开始strlen
//	printf("%d\n", strlen((char *) & arr + 1));//随机值
//	//跳过数组后, 是随机值
//
//	printf("%d\n", strlen(&arr[0] + 1));//5
//
//
//	return 0;
//}

//局部变量在栈区

//int main()
//{
//	const char* p = "abcdef";//常量字符串, 有自己的空间, 把首元素地址放到p中了
//	char s[] = "abcdef";
//	printf("%d\n", sizeof(p));//4/8
//	//p是个指针变量
//	printf("%d\n", sizeof(p + 1));//4/8
//	//字符指针+1, 跳过一个字节, 还是个地址 
//	printf("%d\n", sizeof(*p));//1
//	//访问第一个元素,计算一个字符的大小
//	printf("%d\n", sizeof(p[0]));//1
//	//访问第一个元素,计算一个字符的大小
//	printf("%d\n", sizeof(&p));//4/8
//	//二级指针, 还是指针
//	printf("%d\n", sizeof(&p + 1));//4/8
//	//二级指针+1 , 跳过4/8个字节(跳过了指针), 还是个指针
//	printf("%d\n", sizeof(&p[0] + 1));//4/8
//	//取到a,跳过一个字节, 找到b的地址, 还是个指针
//
//
//	printf("%d\n", strlen(p));//6
//	//从a开始
//	printf("%d\n", strlen(p + 1));//5
//	//printf("%d\n", strlen(*p));//err
//	//printf("%d\n", strlen(p[0]));
//	//printf("%d\n", strlen(&p));//随机数
//	//对p取地址, 从p的地址开始计算, 后面的0不知道在哪
//	//printf("%d\n", strlen(&p + 1));//随机数
//	//对p取地址, 跳过p开始计算, 因为不知道p地址中的值, 所以和上面的随机值值没有关系
//	printf("%d\n", strlen(&p[0] + 1));//5
//	printf("%d\n", strlen(&s[0] + 1));//5
//	//p是字符串首元素地址, 字符串数组名是字符串首元素地址
//	//字符串首元素地址可以用[]解引用, 表示指定字符
//	//p也可以用[]解引用, 表示指定字符, 加1 跳过一个字节, 也就是一个字符.然后从b开始到'\0'有5个元素
//
//		return 0;
//}

//int main()
//{
//
//	int a[3][4] = { 0 };
//	//三行四列, 
//	printf("%d\n", sizeof(a));//48
//	//一整个二维数组, 计算整个数组大小
//	printf("%d\n", sizeof(a[0][0]));//4
//	//第一行第一列元素, 一个整型
//	printf("%d\n", sizeof(a[0]));//16
//	//a[0]是第一行的数组名, 所以(a[0])[0],可以调用到第一行的第一个元素, 所以[0]前面的是个数组名 
//	printf("%d\n", sizeof(a[0] + 1));//4/8
//	//不是单独放在sizeof,数组名是第一行第一个元素的地址,加一后 得到第一行第二个元素地址, 是地址, 就是指针
//	printf("%d\n", sizeof(*(a[0] + 1)));//4
//	//a[0] + 1是第一行第二个元素地址, 那解引用就是元素, int
//	printf("%d\n", sizeof(a + 1));//
//	//虽然是二维数组的地址, 但是并没有单独放在sizeof内部, 也没有取地址
//	//二维数组首元素是它的第一行, a是第一行的地址
//	//a+1就是跳过第一行,表示第二行的地址 
//	printf("%d\n", sizeof(*(a + 1)));//16
//	//对第二行地址的解引用, 得到的是第二行整个数组
//	//*(a+1) -> a[1] :等价
//	printf("%d\n", sizeof(&a[0] + 1));//4/8
//	//a[0]第一行的数组名, 取地址得到数组指针(存放着第一行的地址), 地址+1得到第二行的地址,是个数组指针
//	printf("%d\n", sizeof(*(&a[0] + 1)));//16
//	//得到第二行
//	printf("%d\n", sizeof(*a));//16
//	//没有单独放在内部, 有个解引用标志.就是第一行地址
//	//对第一行解引用, 拿到的就是第一行
//	printf("%d\n", sizeof(a[3]));//16
//	//第四行的数组名, 数组名单独放在sizeof就是整个数组, 所以计算的是第四行的大小(不会访问, 但会计算, 根据限制只能有四列), 所以大小事16
//
//	return 0;
//}


//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int* ptr = (int*)(&a + 1);
//	//&a -> 数组指针, &a + 1 跳过了数组a, 然后传给了ptr, 指向5后面的地址
//	printf("%d,%d", *(a + 1), *(ptr - 1));
//	//ptr-1 得到5的地址, 解引用得到元素5
//	//a+1就是第二个元素, 解引用得到元素2
//	return 0;
//}

//加减的权限, 跳过的字节, 取决于加减数的类型

//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p = (struct Test*)0x100000;
//左边类型是指针, 右边是整型
//所以强制转换成指针

//假设p的值是0x100000 
//Test类型的变量大小是20个字节
//x86

//int main()
//{
//	printf("%p\n", p + 0x1);
//	//一个什么类型的指针,+1, 跳过类型大小的字节
//	//所以跳过了一个结构体大小, 加了20个字节
//	//0x100000 + 20 -> 0x100014
//	printf("%p\n", (unsigned long)p + 0x1);
//	//把一个值当作地址打印出来
//	//整型+1, 就是加一
//	//0x100001
//
//	printf("%p\n", (unsigned int*)p + 0x1);
//	//整型指针+1, 加4个字节
//	//0x100004 
//	return 0;
//

//int main()
//{
//	int a[4] = { 1, 2, 3, 4 };
//	//01 (ptr2)00 00 00 02 00 00 00 03 00 00 00 04 00 00 00(ptr1)
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);
//	//地址+1, 强行转化成int*, 所以从起始位置, 找四个字节, 计算出一个整型
//	printf("%x,%x", ptr1[-1], *ptr2);
//	//%x, 以16进制打印
//	//ptr2往后访问一个整型
//	return 0;
//}

//低位(个位)放在低地址, 高位放在高地址 -> 小端存储模式
//小端存储 -> 取出数字就是从 高地址(第一个取出来的是高位)像低地址(低位) 取出 

//int main()
//{
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };//此处为小括号, (逗号表达式) ','从前向后读取元素, 括号的的结果是最后的数字
//					//1         3         5
//	int* p;
//	p = a[0];
//	//a[0]是第一行的数组名(数组名既不是放在sizeof里面,也不是取地址,只有这两种情况才会表示第一行 ), 表示首元素地址
//	//相当于表示a[0][0] -> 也就是&a[0][0]
//	printf("%d", p[0]);// p[0] -> *(p+0)
//	return 0;
//}

//int main()
//{
//	int a[5][5];
//	int(*p)[4];//p指向一个数组(四个整型), 加一一次跳过四个整型
//	p = a;//首元素地址赋予给一个数组指针
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//	//p的类型是整型, 权限是4个字节, 一次跳过4个字节, 
//	//a是5行5列, 二十五个整型
//	//p的首地址在a的首地址处
//	//p是4列, *(*(p+4)+2)一次跳过四个p(大小为四个整型的一维数组指针), 最后再跳两个整型, 在第十八个整型的位置
//	//a[4][2] -> *(*(a+4)+2),取第四行,第二个,在第22个整型位置
//	//指针相减, 得到的相差的类型数18-22 = -4
//	//数组是由 低地址 到 高地址 储存
//
//
//	//%d -> 得到的就是-4
//	//%p -> 以地址形式, 那就是-4的地址, -4在内存中以补码存在, 打印地址没有什么说法, 直接打印补码
//	//10000000000000000000000000000100
//	//11111111111111111111111111111011
//	//11111111111111111111111111111100补码, 直接打印
//	//0x(高位)(高端)FF FF FF FC(低位)(低端)  ->  FC FF FF FF 0x
//	//p[4][2] -> *(*(p+4)+2)
//	return 0;
//}


//int main()
//{
//	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
//	int* ptr1 = (int*)(&aa + 1);//&aa得到整个数组地址, +1跳过整个数组
//	int* ptr2 = (int*)(*(aa + 1));//等价于aa[1], 就是第二行的数组名!!!!!!!!要学会等价成 [ ]
//	//aa是第一行的地址, +1跳过第一行
//	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
//	return 0;
//}

//int main()
//{
//	const char* a[] = { "work","at","alibaba" };
//	//char* 是一个字节, 也是一个字节   ---   所以存入的是'w', 'a', 'a'的地址
//	//指针数组, 每个元素都是char* 
//	const char** pa = a;
//	//二级指针 存放一级指针, 放的是'w'的地址
//	pa++;
//	//pa + 1指向'a'的地址(pa的指向是char*, 一次跳过一个char*类型)
//					   //(int* p, p指向int*类型, 加一一次跳过一个int*类型)
//	printf("%s\n", *pa);
//	return 0;
//}

//int main()
//{
//	const char* c[] = { "ENTER","NEW","POINT","FIRST" };//c是E N P F 得地址
//	const char** cp[] = { c + 3,c + 2,c + 1,c };//cp是 F P N E 的地址的地址
//	const char*** cpp = cp;//cpp是 F的地址的地址的地址
//	printf("%s\n", **++cpp);//+1的到P的地址的地址的地址, 解引用两次得到 POINT
//	printf("%s\n", *-- * ++cpp + 3);//cpp+1 因为上面进行了"cpp = cpp + 1"的赋值,所以这次加一得到的是指针c+1的地址, 解引用得到指针c+1, 减一得到指针c, 解引用得到E, 加三跳过三个char*, 得到ER
//	//加法的运算符等级很低
//	printf("%s\n", *cpp[-2] + 3);//
//	//*cpp[-2] = **(cpp-2)+3
//	//cpp此时指向c+1的位置, 减二指向c+3, 解引用两次得到F的地址, +3 跳过三个字符的地址, 指向S, 再打印直到'\0', 得到ST
//	printf("%s\n", cpp[-1][-1] + 1);
//	//cpp[-1][-1] + 1 = (*(*(cpp-1)-1)) + 1, cpp此时指向c+1, 减一指向c+2解引用指向POINT的地址, 减一指向NEW的地址, 解引用得到N, 加一指向E, 从这开始打印直到'\0', 得到EW
//	return 0;
//}
//只有前两个自加自减是有改变, 而下面是不带赋值.
//数据的内存存储方式很重要