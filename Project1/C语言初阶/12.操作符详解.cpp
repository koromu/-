#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
//int main()
//{
//	//一.算数操作符
//	//1.整型的除法		1 / 2 = 0,
//
//	//2.浮点型的除法	1.0 / 2 = 0.5
//	//					1 / 2.0 = 0.5两边至少有个浮点数
//
//	//3.取模操作符		% 取模操作符的两段必须是整数
//
//
//	//二.移位操作符
//	//1.<<	左移操作符
//	
//	//int a = -7;		//a的值不变
//	//int b = a << 1;//按照下面的推断b是向左移动移位, 结果是7->14 -7->-14
//	//printf("a=%d\n", a);
//	//printf("b=%d\n", b);
//	//整数的二进制表示有3种: 原码 反码 补码
//
//
//	//正的整数的原码,反码,补码是要计算的
//	//eg:7
//	//0(符号位0是正数)00000000000000000000000000000111(原码)
//	//0(符号位0是正数)00000000000000000000000000000111(反码)
//	//0(符号位0是正数)00000000000000000000000000000111(补码)
//	//eg:-7
//	//1(符号位1是负数)00000000000000000000000000000111(原码)
//	//1(符号位1是负数)11111111111111111111111111111000(反码)(原码的符号位不变,其它的位按位取反)
//	//1(符号位1是负数)11111111111111111111111111111001(补码)(反码+1就是补码,满2进位)
//	
//	//整数在内存中的存储是补码
//	//移位就是移动补码
//	//左移操作符:
//	//左边丢失,右边补0
//
//	//打印室打印原码
//	//左移右移只针对整数
//
//	//2.>>	:右移操作符(vs2022, 编译器采用的算数位移)
//	//2.1 : 算数移位 :右边丢失, 左边补原符号位(保留原来符号)
//	//2.2 : 逻辑移位 :右边丢失, 左边补0(符号丢了呀)
//	//int a = -7;		//a的值不变
//	//int b = a >> 1;//按照下面的推断b是向右移动移位, 结果是7->3 -7->-4
//	//printf("a=%d\n", a);
//	//printf("b=%d\n", b);
//	//移的位需要时正数,负数未定义,可能得不到目标数字
//
//
//	//三.位操作符
//	//1.& - 按(2进制)位 与 (使用补码)(与的结果: 只有两个都是1,才的=得1)
//	//		1.1	同真1	异假0
//	//2.| - 按(2进制)位或
//	//		2.1一个为真就是真
//	//3.^ - 按(2进制)位异或
//	//		3.1 同假0	异真1
//	//整数4字节一个字节8个比特位
//	//10000000000000000000000000000101 - -5的原码
//	//11111111111111111111111111111010 - -5的反码
//
//	//00000000000000000000000000000011 - 3的补码
//	//11111111111111111111111111111011 - -5的补码
//
//	//00000000000000000000000000000011 = a&b 的补码 = 
//
//	//11111111111111111111111111111011 = a|b 的补码
//	//11111111111111111111111111111010	符号位不变哦!!!
//	//10000000000000000000000000000101 = a|b 的原码 = -5
//
//	//11111111111111111111111111111000
//	//11111111111111111111111111110111
//	//10000000000000000000000000001000 = a^b 的原码 = 8
//
//	//%d 以为着打印一个有符号的整数(原码)
//	//补码储存在内存
//
//	//int a = 3;
//	//int b = -5;
//	//int c = a & b;
//	//printf("c = %d\n", c);
//	//int a = 3;
//	//int b = -5;
//	//int c = a | b;
//	//printf("c = %d\n", c);
//	//int a = 3;
//	//int b = -5;
//	//int c = a ^ b;
//	//printf("c = %d\n", c);
//	//3 ^ 3 = 0; -> a ^ a = 0;
//	//0 ^ 5 = 5; -> 0 ^ a = a;
//
//	//3 ^ 5 ^ 3 = 5;
//	//3 ^ 3 ^ 5 = 5; -> 异或支持交换律
//
//
//	//练习:不创造临时变量(第三个变量), 实现两个变量的交换
//	//int a = 99;
//	//int b = 66;
//	//////a = a + b;
//	//////b = a - b;
//	//////a = a - b; // 方法一:会有溢出的问题
//	//a = a ^ b;
//	//b = b ^ a;
//	//a = a ^ b;//异或的交换律
//	////根据二进制可以理解
//	//printf("交换前a = %d, b =%d\n", a, b);
//
//	//printf("交换后a = %d, b =%d\n", a, b);
//
////练习题
////编写代码实现,求一个整数储存在内存中的二进制中1的个数
////int a = 3;
////00000000000000000000000000000011
////a & 1得到的结果就是,a的二进制的最低位的数- 1 / 0
////然后右移一位, 在得到二进制的第二位
//
//
//
////赋值操作符
//// 1.	= 
////		在创建变量的时候赋值, 叫做初始化
////		创建变量之后赋值, 叫做赋值
//// 2.	符合操作符:　+= -= >>= <<= &= ^= 
//
//
//
////四.单目操作符(运算符): 只有一个操作数
////1. ! 把真的变成加, 把假的变成真
//
////int flat = 3;
////if (flag)
////{
////	;
////}
////if (!flag)
////{
////	;
////}
//
////2. + - 加减号
//
//
////3. & 取地址操作符
////int a = 10;
//////printf("%p\n", &a);//每一次的位置不一样,地址不一样
//////取出变量的第一个字节的地址
////
////int n = sizeof(a);	//计算的是变量(类型)所占内存空间的大小
//					//计算类型所创建的变量的大小,单位是字节
//
//
////int arr[] = { 1, 2, 3, 4, 5 };
//////可以计算数组的大小, 每个都是一个整型, 40个字节
////int n = sizeof(arr);
////printf("%d\n", n);
//
//
////4. ~ 是按二进制位取反
//	//int a = 0;
//	  //~ a = -1  //正确的
//	  //取反后得到得到是补码
//	//printf("%d\n", ~a);
//
////应用:
////int a = 13;
////00000000000000000000000000001101
////按位或
////00000000000000000000000000000010 -> 通过1的移位得到
////得到
////00000000000000000000000000001111  把0变成1 -> 用1的移位,按位或 (|) ,可以把1补充到目标上
////									把1变成0 -> 用1的按位取反,再 移位,按位于(|)
////5.加加,减减
////++			前置是先加,后使用
////--			后置是先使用,后加
////也是单目操作符,只对一个操作数使用
//
//
////6.间接访问操作符
////int a = 10;
////int* p = &a;
////*p = 20;//可以改变a
////通过p间接访问a
//
//int a = (int)3.14;//(原本是double, 强制转化成int)
//// time函数中强制转换 time_t(long long类型) -> unsigned int(整型类型) 
//
////sizeof后面的括号可以省略,所以是操作符,不是函数
////strlen后面的括号不可以省略,因为他是函数
//
////指针变量是4/8个字节, x86是4个字节
//
//// 五.比较操作符
//
////1. ==
////abc == abcdrf;比较的是地址是否相等
//
////2.&& 逻辑与(并集)
////									: 并且左右两边的都是条件, 如果是0就直接是假,右边的也不用判断了
//
////赋值是最后计算
//
////有一个假就是假, 返回值是1 或者 0 
////3.|| 逻辑或(或者)					: 从左往右, 有一个为真,后面的都是跳过
////只有同时为假的时候才为假
//
////判断闰年;能被四整除,并且不能被100整除,  能被400整除
//
////七.条件操作符:三目操作符
////(exp1 ? exp2 : exp3) 一整个表达式
////b = (a > 5 ? 3 : -3);
////int max(a > b ? a : b);
//
////八.逗号表达式, 用逗号隔开多个表达式, 从左向右依次执行, 整个表达式的结果是最后一个表达式的结果
//
////九. 下标引用[]操作符 
//// int arr[7] = 8;
//// 7[arr] = { 0 };	(后者不能初始化)	这两个是相等的,可见这[]是一个二目操作符
//
////arr是数组的首元素地址
////arr + 7 是跳过7个元素 指向第八个元素
////*(arr + 7)就是第八个元素, 加法交换律 *(7 + arr)
//
//
////十.函数定义:
////  函数调用操作符 ( )
//
////int a = 30;
////int b = 10;
////int c = Add(a, b);//是个操作符 
//
////十一.结构体操作符 .  ->
//
////struct Stu s = { 0 };
////set_sty(&s);
////print_stu(&s);  //直接使用值,不用重新定义新的字符,浪费空间
//
//
//
//	return 0;
//}

//int Add(int x, int y)
//{
//	return x + y;
//}

//struct  Stu
//{
//	char name[20];
//	int age;
//	double score;
//};
//
//
//void set_stu(struct Stu* ps)
//{
//	//赋值
//	(*ps).age = 10;
//	(*ps).score = 100.0;
//	//ss.name = "nihao" // ss.name中name是个数组 单独引用一个数组名的意思是地址
//	
//	//函数strcpy((*ps).name, "拷贝内容") 拷贝函数
//	
//	strcpy((*ps).name, "拷贝内容");//使用指针变量(此处为结构体指针),间接远程找到值在引用"."
//		//还有使用: 结构体对象.成员
//		//			结构体指针->成员
//	
//	//ps->age = 10;
//	//ps->score = 100.0;
//	//strcpy(ps->name, "名字");
//
//
//}








