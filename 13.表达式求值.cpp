#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

//int main()
//{
//	//int a = 2 + 6 / 3;//优先级
//	//int b = 2 + 3 + 4;//结构性(表格)
//
//	//1.1隐式类型型转换
//	//C的整型算术运算总是至少以缺省(默认)整型类型的精度来进行的
//	//为了获得这个精度,表达式中的字符和短整型操作数在使用之前被转换成普通整型, 这种转换成为:整型提升
//	
//	//cpu中alu的操作数一般是int的字节长度
//	//所以就先提升成int,再计算
//
//	//整形提升:按照符号位补充高位
//	//char c = -1;
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111 -> -1 的补码
//	//11111111 -> c就是取前8个比特位(从低位开始), 一个字节
//	//符号位是1;直接补1 : 1"11111111111111111111111"11111111中间的是补的
//	//char a = 5;
//	//00000000000000000000000000000101
//	//00000101
//	//char b = 126;
//	//00000000000000000000000001111110
//	//01111110
//	//char c = a + b;
//	//00000101
//	// 提升: 00000000000000000000000000000101
//	//01111110
//	//提升:  00000000000000000000000001111110
//	//相加:  00000000000000000000000010000011
//	// 再下降变成;10000011
//
//	//printf("%d\n", c);
//	//打印是还要提升,因为打印整型
//	//11111111111111111111111110000011 -> 补码
//	//11111111111111111111111110000010 -> 反码
//	//10000000000000000000000001111101 -> 原码, 读取就是读取原码,储存是储存补码
//
//	//在表达式的类型,非整型的操作数在使用是需要整型提升
//
//
//	//1.2: 算术转换
//	//不同类型的操作数,需要通过巡场算术转换得到相同类型(这中间有优先级)
//	
//	
//	//注意"优先级"(考虑相邻操作符). -> 优先级相同,取决于"结合性". -> "是否遵循结构顺序":逻辑与, 逻辑或, 条件操作符(?:), 逗号.
//	//a*b + c*d + e*f -> 问题表达式: 需要加上括号
//	// c + --c -> 问题表达式: c的值的准备时间不知道,--之前和之后的到的结果是不一样的
//	
//	//int i = 10;
//	//i = i-- - --i *(i = -3)* i++ + ++i
//
//	//static int count = 1; //静态变量,定义一次
//	//错误代码,在不同的编译器,有不同的结果int b = (++a) + (++a) + (++a)//计算路径不唯一 vs2022, lenux
//	
//
//	return 0;
//}