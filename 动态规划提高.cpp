#define _CRT_SECURE_NO_WARNINGS
//导弹拦截
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 1010;
//
//int n;
//int q[N], f[N], g[N];//这里的f[i]表示, 以第i个结尾能拦截的导弹个数最多的一种情况
//
//int main()
//{
//	while (cin >> q[n]) n++;//这个方法读入, 直到没有数读入, 可以读到每一个数字, 还可以记录n, 也就是数字的个数
//
//	int res = 0;//记录下降子序列的长度, 也就是一个系统可以拦截的导弹的个数
//	for (int i = 0; i < n; i++)
//	{
//		f[i] = 1;
//		for (int j = 0; j < i; j++)
//		{
//			if (q[j] >= q[i])//如果前面的导弹比后面的导弹高, 就进入判断
//				f[i] = max(f[i], f[i] + 1);//更新f[i], 固定第i个不变, 然后考虑上一个拦截的导弹的是哪个, 取这些之间的最大值, 前面的导弹的最大值+1就是这个i的答案, 前面的导弹是已经处理好的了
//			res = max(res, f[i]);//顺便更新答案
//		}
//	}
//
//	cout << res << endl;
//
//	int cnt = 0;//记录需要多少个系统, 需要求的最小值
//	for (int i = 0; i < n; i++)
//	{
//		int k = 0;
//		while (k < cnt && g[k] < q[i])k++;//首先第一次循环,这个函数会把一个导弹的高度存放到一个g[0]中, 只有当有一导弹的高度可以进行下降, 那么就退出循环, 把这个导弹存到g[k]中, 这个循环相当于从1 ~ cnt找到第一个 q[i]使得它 <= g[k]也就是合法, 然后存入
//		//这个k如果一直不合法, 那么就会到k = cnt 然后再g[k]存入q[i];比如cnt是1的时候, 代表着有一个系统, 如果没有能放进的合法的系统的话, 那么k就等于1了, 然后再g[1]中存放这个高度, 把k作为下标的话, 这个数也就是存进一个新的数组中
//		g[k] = q[i];//这里表明; 在这个g中存放的是导弹高度, 因为在这个大循环中k是会变的, i是不变的.
//		//这个循环是遍历k, 也就是每一个系统, 其中g[k]存放的是这个系统当前最末尾的一个高度, 也就是这个系统最小的一个数, 而while循环是拿每一个q[i]和这一个个系统的最小值比较,找到的是g[k] 
//		
//		if (k >= cnt) cnt++;//当k == cnt也就是在这里把cnt++;如果一开始是1的话, 到这里就是2了, 个数是2, 在g数组中, 下标是0 1也是两个数
//	}//只会遍历一遍, 所有导弹都会放进一个系统中
//	cout << cnt << endl;
//	return 0;
//}

//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 55;
//
//int n;//总共的导弹数量
//int h[N];//高度数组
//int up[N], down[N];//分别存放所有上升子序列的最末尾的数据和所有下降子序列的最末尾的数据
//int ans;//记录总共需要多少个系统
//
//void dfs(int u, int su, int sd)
//{
//    if (su + sd >= ans) return;//如果上升的和下降的数量加起来已经大于等于最大值, 就不能是答案了, 退出
//    if (u == n)
//    {
//        ans = min(ans, su + sd);
//        return;
//    }//如果当前的层数和也就是拦截的导弹和需要拦截的数量相同, 则找到了答案, 更新一下, 退出
//
//    int k = 0;//方法和找上升子序列一样
//    while (k < su && up[k] >= h[u]) k++;//先找到第一个合法的数据, 如果h[u] > 一个上升子序列的末尾的数据, 就退出, 拿这个数据进行下一步
//    if (k < su)//如果真的在存在得系统中找到了的话就进入
//    {
//        int t = up[k];//保存起来, 等到出来以后可以恢复现场
//        up[k] = h[u];//把这个数据存入其中
//        dfs(u + 1, su, sd);//然后用前面的数据去更新后面的数据, 此处层数增加(拦截的导弹数量增加), 但是没有增加系统数, 所以 u + 1, sd ,su不变
//        up[k] = t;//恢复现场
//    }
//    else
//    {//如果所有的上升子序列都没有合法的, 就直接开一个新的
//        up[k] = h[u];//此时的k是从1开始得个数, 作为下标多了一个1, 所以直接使用就相当于在数组的最新的位置, 直接存入这个导弹的高度
//        dfs(u + 1, su + 1, sd);//因为上升子序列的系统和拦截导弹的数量增加了, 所以u 和 su 加 1, sd不变
//    }
//
//    k = 0;//下降子序列系统原理几乎一样
//    while (k < sd && down[k] <= h[u]) k++;
//    if (k < sd)
//    {
//        int t = down[k];
//        down[k] = h[u];
//        dfs(u + 1, su, sd);
//        down[k] = t;
//    }
//    else
//    {
//        down[k] = h[u];
//        dfs(u + 1, su, sd + 1);
//    }
//}
//
//int main()
//{
//    while (cin >> n, n)//有多个测试用例, 直到读入0
//    {
//        for (int i = 0; i < n; i++) cin >> h[i];//读入所有哦高度
//
//        ans = n;//初始化成最大值
//        dfs(0, 0, 0);//深度优先遍历的使用全局变量记录找最小值
//
//        cout << ans << endl;
    //}
//
//    return 0;
//}
//#include <cstdio>
//#include <iostream>
//#include <algorithm>
//
//using namespace std;
//
//const int N = 3010;
//
//int n;
//int a[N], b[N];//分别存入两个数组
//int f[N][N];//代表
////f[i][j]代表所有a[1 ~i]和b[1 ~j]中以 b[j] 结尾的公共上升子序列的集合, 它的值等于该集合的子序列中长度的最大值
//
//int main()
//{
//    scanf("%d", &n);
//    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
//    for (int i = 1; i <= n; i++) scanf("%d", &b[i]);
//
//    //for (int i = 1; i <= n; i++)
//    //{
//    //    for (int j = 1; j <= n; j++)
//    //    {
//    //        f[i][j] = f[i - 1][j];//直接赋值, 不含a[i]
//    //        if (a[i] == b[j])//考虑含a[i]的情况
//    //        {
//    //            int maxv = 1;//这个值是随着j的变化而变化的, i是不变的, 这个值得变化是从1 ~ j变化的, 后面的j是使用前面的j更新的, 前面的j会影响到后面的j, 但是后面的j不会影响到前面的, 所以求后面的j时可以记录前一个maxv的最大值, 只使用一个maxv更新后面的, 不用全部求一遍了 
//    //             for (int k = 1; k < j; k++)
//    //                if (b[j] > b[k])
//    //                    maxv = max(maxv, f[i - 1][k] + 1);
//    // 
//    //            //这个循环找到的maxv就是 含a[i], 不含b[j]的最大值, 也就是f[i][j-1]
//    //            f[i][j] = max(f[i][j], maxv);//最后更新这, 取 含b[j] 和 不含b[j] 的最大值
//    //        }
//    //    }
//    //}
//
//    //此处等价变换, 因为a[i] = b[j]
//    //所以条件变成a[i] > b[k] 变成了一个与j无关的不等式
//    for (int i = 1; i <= n; i++)
//    {
//        int maxv = 1;//所以把maxv定义在第二重循环外面, 从 1 开始
//        for (int j = 1; j <= n; j++)
//        {
//            f[i][j] = f[i - 1][j];
//            if (a[i] == b[j]) f[i][j] = max(f[i][j], maxv);
//            if (a[i] > b[j]) maxv = max(maxv, f[i - 1][j] + 1);//更新放到了每一个j中, 只要每一步都尽可能的更新maxv, 就不用每次求一遍了 
//            //原条件是满足上升子序列也就是 b[k] < b[j] 因为 b[j] == a[i] 所以可以变成b[k] < a[i]
//            //k表示 1 ~ j-1 全部求一遍, 现在这个循环的j从1开始, 把每一个j都求到, 所以b[k]就是b[j]
//        }
//    }
//
//    int res = 0;
//    for (int i = 1; i <= n; i++) res = max(res, f[n][i]);
//    printf("%d\n", res);
//
//    return 0;
//}

